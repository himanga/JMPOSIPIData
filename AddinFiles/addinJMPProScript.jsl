/* About: This file is used to create the script to load a 
          a data table into JMP Pro

*/

Names default to here( 1 );

// About: Customize this file
// Set this to the add-in ID
thisAddIn = "com.github.himanga.JMPOSIPITools";

// About: get or make namespace for this add-in
If( 
	!Namespace Exists( Eval( thisAddIn ) || ".addinnamespace" ),
	ns = New Namespace( Eval( thisAddIn ) || ".addinnamespace" ),
	ns = Namespace( Eval( thisAddIn ) || ".addinnamespace" )
);
ns:logusage( "Create JMP Pro Script" );
//Create JSL script from options on the form.
BuildJSL = function( {}, {txt},

	// Get inputs
	serverName = tb_server << GetText;
	querytype = rb_querytype << Get Selected;
	searchfield = rb_SearchField << Get Selected;
	cnformat = cb_cnformat << Get Selected;
	matchType = rb_matchtype << Get Selected;
	searchStrings = Words( TagList << Get Text, "\!N");
	calculationBasis = rb_calctype << GetSelected;
	startTime = TimeStart << GetText;
	endTime = TimeEnd << GetText;
	intervalTime = TimeInterval << GetText;
	If(SeparateInterval << Get(1) == 0,
		// Use the interval as the time step if there is no separate interval
		stepTime = intervalTime
	,
		stepTime = TimeStep << GetText
	);
	TableFormat = rb_tblformat << getSelected;
	
	oldcn = ns:map(searchStrings,
		function( {x}, Uppercase( Char( FieldFromLine( "tag", x || "\!N" ) ) ) )
	);
	
	newcn = ns:map(searchStrings,
		function( {x}, FieldFromLine( cnformat, x || "\!N" ) )
	);
	
	taggroups = ns:map(searchStrings,
		function( {x}, FieldFromLine( "group", x || "\!N" ) )
	);

	ColToSplit = If( 
		(querytype == "Interpolated Values" | querytype == "All Archived Values"), 
		{:value, :svalue, :status},
		{:value}
	);

	// Insert all JSL needed to produce the intended table into this Glue expression
	NewTblExpr = EvalExpr(Glue(
		NamesDefaultToHere(1);
		// Requires the addin's namespace
		nsName = "com.github.himanga.JMPOSIPITools.addinnamespace";
		If(!Namespace Exists(nsName),
			ns = New Namespace(nsName),
			ns = Namespace(nsName)
		);
		// Base URL to be used by all requests
		ns:baseURL = expr(tb_BaseURL << getText);
		// Max number if items returned used by all requests
		ns:maxRows = expr(num(tb_maxrows << getText));
		// Use the minumum of the user specified maxRows and the API Row limit as the number of rows to pull in a single request
		ns:maxCount = minimum(ns:maxRows, ns:APIRowLimit);
		// Gets the data server's web ID based on the user's preferences
		serverid = ns:DataServerIdRequest(expr(serverName));
	));

	// Get pointIDs
	If(searchField == "webID",
		InsertInto(NewTblExpr,
			evalExpr(pointIDs = expr(searchStrings))
		)
	,//else, need to request pointIDs
		InsertInto(NewTblExpr,
			evalExpr({pointIDs, pointNames} = ns:PointRequest(serverid, expr(oldcn), expr(searchfield), expr(matchType)))
		)
	);

	// Call a Table function depending on the query type
	tableRequestExpr = Match(querytype,
		"Point Info",
			Expr(dtLong = ns:GetPointAttributesTable(pointIDs)),
		"Snapshot Values",
			Expr(dtLong = ns:GetSnapshotValuesTable(pointIDs)),
		"All Archived Values",
			EvalExpr(dtLong = ns:GetArchiveValuesTable(pointIDs, pointNames, Expr(startTime), Expr(endTime))),
		"Interpolated Values",
			EvalExpr(dtLong = ns:GetInterpolatedValuesTable(pointIDs, pointNames, Expr(startTime), Expr(endTime), Expr(intervalTime))),
		"Average",
			EvalExpr(dtLong = ns:GetSummaryValuesTableWithStepTime(pointIDs, pointNames, "Average", Expr(calculationBasis), Expr(startTime), Expr(endTime), Expr(intervalTime), Expr(stepTime))),
		"Count",
			EvalExpr(dtLong = ns:GetSummaryValuesTableWithStepTime(pointIDs, pointNames, "Count", Expr(calculationBasis), Expr(startTime), Expr(endTime), Expr(intervalTime), Expr(stepTime))),
		"Max",
			EvalExpr(dtLong = ns:GetSummaryValuesTableWithStepTime(pointIDs, pointNames, "Maximum", Expr(calculationBasis), Expr(startTime), Expr(endTime), Expr(intervalTime), Expr(stepTime))),
		"Min",
			EvalExpr(dtLong = ns:GetSummaryValuesTableWithStepTime(pointIDs, pointNames, "Minimum", Expr(calculationBasis), Expr(startTime), Expr(endTime), Expr(intervalTime), Expr(stepTime))),
		"Population Standard Deviation",
			EvalExpr(dtLong = ns:GetSummaryValuesTableWithStepTime(pointIDs, pointNames, "PopulationStdDev", Expr(calculationBasis), Expr(startTime), Expr(endTime), Expr(intervalTime), Expr(stepTime))),
		"Range",
			EvalExpr(dtLong = ns:GetSummaryValuesTableWithStepTime(pointIDs, pointNames, "Range", Expr(calculationBasis), Expr(startTime), Expr(endTime), Expr(intervalTime), Expr(stepTime))),
		"Standard Deviation",
			EvalExpr(dtLong = ns:GetSummaryValuesTableWithStepTime(pointIDs, pointNames, "StdDev", Expr(calculationBasis), Expr(startTime), Expr(endTime), Expr(intervalTime), Expr(stepTime))),
		"Totals",
			EvalExpr(dtLong = ns:GetSummaryValuesTableWithStepTime(pointIDs, pointNames, "Total", Expr(calculationBasis), Expr(startTime), Expr(endTime), Expr(intervalTime), Expr(stepTime))),
		throw("Unknown query type")
	);
	InsertInto(NewTblExpr, NameExpr(tableRequestExpr));

	// Check if user's Max Rows is exceeded. For Point Info and Snapshot Value compare to row count.
	// For other queries compare to the most data for any one tag pulled.
	InsertInto(NewTblExpr, EvalExpr(
		if(!contains({"Point Info", "Snapshot Values"}, expr(querytype)),
			dtCount = dtLong << summary(group(:tag), "private");
			rowCount = colMax(column(dtCount, "N Rows"));
			close(dtCount, "nosave");
		,
			rowCount = nRows(dtLong)
		);
		if(rowCount >= ns:maxRows,
			NewWindow("Max Rows Exceeded", <<modal,
				TextBox(
					"Met or exceeded the maximum number of rows (" || char(ns:maxRows) ||
					") for this query. Increase the allowed maxrows or restrict the query. "||
					" Some results might be missing."
				)
			);
			dtLong << BringWindowToFront;
		);
		oldcn = expr(oldcn);
		oldcncorrected = oldcn;
	));

	If(cnformat != "tag",
		//Change Column Names 
		InsertInto(NewTblExpr, EvalExpr(
			newcn = expr(newcn);
			For( i = 1, i <= N Rows( dtLong ), i++,
				pos = Min( Loc( oldcncorrected, Uppercase( Column( dtLong, "tag" )[i]) ) );
				If( pos > 0,
					Column( dtLong, "tag" )[i] = newcn[pos]
				)
			)
		))
	);

	If( TableFormat == "Wide",
		// Make wide table
		InsertInto(NewTblExpr, EvalExpr(
			tableName = dtLong << getName;
			dtWide = dtLong << Split(
				Split By( :tag ),
				Split( expr(ColToSplit) ),
				Group( :time ),
				Remaining Columns( Drop All ),
				Sort by Column Property
			);
			close(dtLong, "nosave");
			dtWide << setName(tableName);
		));
		If(cb_tagtonotes << Get,
			// Save column properties
			InsertInto(NewTblExpr, EvalExpr(
				For( i = 1, i <= N Cols( dtWide ), i++,
					cn = Regex( Column( dtWide, i ) << Get Name, "((value )|(svalue )|(status ))?(.*)", "\5" );
					If( !Is Missing( cn ),
						pos = Min( Loc( oldcn, cn ) );
						If( pos > 0,
							Column( dtWide, i ) << Set Property( "PI tag", oldcncorrected[pos] );
							Column( dtWide, i ) << Set Property( "PI Original Column Name", Column( dtWide, i ) << Get Name );
							Column( dtWide, i ) << Set Property( "PI call type", expr(querytype) );
							Column( dtWide, i ) << Set Property( "PI interval", expr(intervalTime) );
							Column( dtWide, i ) << Set Property( "PI Server", expr(serverName) );
							If( contains({"Average", "Count", "Max", "Min", "Population Standard Deviation", "Range", "Standard Deviation", "Totals"}, expr(querytype)), 
								Column( dtWide, i ) << Set Property( "PI step", expr(stepTime));
								Column( dtWide, i ) << Set Property( "PI interval start offset", "-" || expr(stepTime));
								Column( dtWide, i ) << Set Property( "PI interval end offset", "");
							)
						);
					);
				)
			))
		)
	);
	Return( NameExpr(NewTblExpr) );
);