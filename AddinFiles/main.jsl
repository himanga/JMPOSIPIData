/* About: Get OSI PI Data

Get data from PI Web API. Requires version 2021 SP3 or higher of the PI Web API.

Section: Globals
*/

Names default to here( 1 );

// About: Customize this file
// Set this to the add-in ID
thisAddIn = "com.github.himanga.JMPOSIPITools";

// About: get or make namespace for this add-in
If( 
	!Namespace Exists( Eval( thisAddIn ) || ".addinnamespace" ),
	ns = New Namespace( Eval( thisAddIn ) || ".addinnamespace" ),
	ns = Namespace( Eval( thisAddIn ) || ".addinnamespace" )
);
ns:logusage( "Get PI Data" );


//Function to assign a value to a symbol when the symbol name is pased as a string
assignparsename = function({left, right}, 
	Eval(Substitute(
		Eval List( {as name( name expr( left ) ), right} ),
		Expr({}),
		Expr( assign() )
	) );
);

//Standard box to display description for each input
tbDesc = Function( {descmsg, helpmsg, wdth = 100},
	Eval( Eval Expr(  VCenter Box( 
		Text Box( 
			descmsg,
			<<Set Width( wdth ),
			<< Set Tip( helpmsg )
		)
	) ) )
);

//Standard box to get text info from the user
tebText = Function( {initval, varname, helpmsg = "", wdth = 150,
		fn = function( {this}, UpdateOutput(); ) },
	centeredbox = Eval( (  VCenter Box( 
		tbtemp = Text Edit Box(
			initval,
			<< Justify Text( Left ),
			<< Set Width( wdth ),
			<< SetFunction( fn ),
			<< Set Tip( helpmsg )
		),
	) ) );
	
	Eval( Parse( Eval Insert( "^varname^ = tbtemp" ) ) );
	
	return(centeredbox)
);

//Standard combo box
cbCombo = Function( {values, fn, varname, helpmsg = "", wdth = 150 },
	cbexpr2 = (Eval Expr(  VCenter Box( 
		assignparsename(
			varname,
			Combo Box(
				values,
				<< Set Width( wdth ),
				<< Set Tip( helpmsg ),
				<< Set Function( Expr( Name Expr( fn ) ) )
			)
		)
	) ) );
	centeredbox = Eval( cbexpr2 );
	
	return(centeredbox);
);

//Standard button to display help info
bbHelp = Function( {helpmsg, HelpType = "stdtext" }, {toppad, bb},
	toppad = If( 
		HelpType == "stdtext", -2, 
		HelpType == "stdoutline", 0,
		6
	);
	bb = Eval( Eval Expr( Button Box( "",
		<<Set Icon("WinToolsHelp"),
		<<Set Script( New window( "Help", Modal, Text Box( Expr( helpmsg ), Set Width( 500 ) ) ) ),
		<<Padding( Top(toppad), Left(-2), Right(-2), Bottom(-2) ),
		<< Set Tip( helpmsg )
	) ) );
	
	If( 
		HelpType == "stdtext", 
		return( V Center Box( bb ) ), 
		return( bb )
	);
);

//standard spacer between inputs
sbDefault = Function( {}, Spacer Box( Size( 3, 3 ) ) );

//Standard line for text input
stdtxtInput = Function( { varname, descmsg, initval, helpmsg, nlines = 1, descwidth = 100,
		fn = function( {this}, UpdateOutput(); ) },

	Eval( Eval Expr(
		H List Box(
			tbDesc( Expr( descmsg ), helpmsg ),
			
			sbDefault(), 
			
			tebText( initval, varname, helpmsg ),
			
			sbDefault(), 
			
			bbHelp( helpmsg )
			
		)
	) )
);

//Standard combobox input
stdcbInput = Function( { descmsg, varname, values, fn, helpmsg },
	
	H List Box(
		Eval( Eval Expr( 
			tbDesc( Expr( descmsg ), helpmsg )
		) ),
		
		sbDefault(), 
		
		cbexpr = (Eval Expr(
			cbCombo( Expr( Name Expr( values ) ), Name Expr( fn ), varname, helpmsg )
		));
		
		Eval(cbexpr),
		
		sbDefault(), 
		
		bbHelp( helpmsg )
		
	)
);

//Set default Table format
DefaultTableFormat = function( {},
	querytype = rb_querytype << Get Selected;
	
	//Show or hide time options
	if( querytype == "Point Info" |
		querytype == "Snapshot Values" |
		querytype == "All Archived Values" |
		querytype == "Calculated Expression",
		rb_tblformat << Set( 1 ),
		
		lb_querytimes << Visibility("visible");
		rb_tblformat << Set( 2 );
	);
	
);

SizeTextBoxes = function( {},
	boxes = { {TagList, TagListsb} };
	for(i = 1, i <= N Items(boxes), i++,
		Eval( Eval Expr( 
			tbtmp = Text Box( Expr( boxes[i][1] ) << Get Text, set wrap( Expr( boxes[i][1] ) << Get Wrap), set width( Expr( boxes[i][1] ) << Get Width ), hide(0)); 
		) );
		tbtmp_nw = New Window("test", tbtmp);
		tbtmp_height = (tbtmp << Get Size)[2];
		tbtmp_nw << Close Window;
		
		Eval( Eval Expr(
			Expr( boxes[i][1] ) << Set Height( max( tbtmp_height, ( Expr( boxes[i][2] ) << Get Height) - 30 ) );
			Expr( boxes[i][1] ) << Set Width( max( 100, (Expr( boxes[i][2] ) << Get Width) - 30 ) );
		) );
	)
	
);

// Set textbox with JSL
UpdateOutput = function( {},
	
	if( DisableUpdate == 1, return());
	
	three_rb = rb_tblformat << Get selected;
	if (three_rb == "Long",
		TableFormat = "Long";,
		three_rb == "Wide",
		TableFormat = "Wide";,
		TableFormat = "Long";
	);

	querytype = rb_querytype << Get Selected;
	calctype = rb_calctype << Get Selected;
	searchfield = rb_SearchField << Get Selected;
	
	//Show or hide time options
	if( querytype == "Point Info",
		lb_querytimes << Visibility("collapse");
		lb_CalcBasis << Visibility("collapse");
		lb_intervaltime << Visibility("collapse");
		lb_steptime << Visibility("collapse");
		lb_searchfield << Visibility("visible");
		lb_matchtype << Visibility("visible");
		rb_tblformat << Set( 1 );
		lb_longwide << Visibility("collapse");
	,
	
		querytype == "Snapshot Values",
		lb_querytimes << Visibility("collapse");
		lb_CalcBasis << Visibility("collapse");
		lb_intervaltime << Visibility("collapse");
		lb_steptime << Visibility("collapse");
		lb_searchfield << Visibility("visible");
		lb_matchtype << Visibility("visible");
		rb_tblformat << Set( 1 );
		lb_longwide << Visibility("collapse");
	,
		
		querytype == "All Archived Values",
		lb_querytimes << Visibility("visible");
		lb_CalcBasis << Visibility("collapse");
		lb_intervaltime << Visibility("collapse");
		lb_steptime << Visibility("collapse");
		lb_searchfield << Visibility("visible");
		lb_matchtype << Visibility("visible");
		lb_longwide << Visibility("visible");
	,
		
		querytype == "Interpolated Values",
		lb_querytimes << Visibility("visible");
		lb_intervaltime << Visibility("visible");
		lb_steptime << Visibility("collapse");
		lb_CalcBasis << Visibility("collapse");
		lb_searchfield << Visibility("visible");
		lb_matchtype << Visibility("visible");
		lb_longwide << Visibility("visible");
	,
		/*
		querytype == "Calculated Expression",
		lb_querytimes << Visibility("visible");
		lb_steptime << Visibility("collapse");
		lb_CalcBasis << Visibility("collapse");
		lb_searchfield << Visibility("collapse");
		lb_matchtype << Visibility("collapse");
		rb_tblformat << Set( 1 );
		lb_longwide << Visibility("collapse");
		,
		*/
		lb_querytimes << Visibility("visible");
		lb_intervaltime << Visibility("visible");
		// Separate step time only allowed for TimeWeighted basis
		if(calctype == "TimeWeighted",
			lb_steptime << Visibility("visible")
		,
			TimeStep << Set Text (TimeInterval << Get Text);
			lb_steptime << Visibility("collapse")
		);
		lb_CalcBasis << Visibility("visible");
		lb_searchfield << Visibility("visible");
		lb_matchtype << Visibility("visible");
		lb_longwide << Visibility("visible");
		JMPJSLout
	);

	//If step and interval times are linked, update the interval time
	If( ( SeparateInterval << Get ) == 1,
		lb_steptimesub << Visibility("visible");
	,
		lb_steptimesub << Visibility("collapse");
		TimeStep << Set Text( TimeInterval  << Get Text );
	);
	

	
	// Open the outline box before reformatting or the JSL gets formatted for very narrow script box
	// JMP Script
	JMPJSLout << set text( Char(BuildJMPJSL()));
	wasJMPOpen = obJMPJSLScript << GetOpen;
	obJMPJSLScript << setopen(1);
	JMPJSLout << Reformat;
	obJMPJSLScript << setopen(wasJMPOpen);

	// JMP Live Script
	LiveJSLout << set text( Char(BuildLiveJSL()));
	wasLiveOpen = obLiveJSLScript << GetOpen;
	obLiveJSLScript << SetOpen(1);
	LiveJSLout << Reformat;
	obLiveJSLScript << setopen(wasLiveOpen);

	If( searchfield == "webID",
		lb_matchtype << set(1); // Exact matches only
		tb_tagnameshead << Set Text( "Web IDs" );
		lb_matchtype << Visibility("collapse"),
		tb_tagnameshead << Set Text( "Tag Names" );
		lb_matchtype << Visibility("visible")
	);
	
	SizeTextBoxes();
	
);

FieldFromLine = function( {field, line}, {r, rx},
	rx = "^([^;\n\r]+)(;([^;\n\r]+))?(;([^;\n\r]+))?(\n|\r)";
	if( field == "tag", r = regex( line, rx, "\1"),
		field == "friendly", r = regex( line, rx, "\3"),
		field == "friendlytag", r = regex( line, rx, "\3 (\1)"),
		field == "group", r = regex( line, rx, "\5"),
		field == "grouptag", r = regex( line, rx, "\5 - \1"),
		field == "groupfriendly", r = regex( line, rx, "\5 - \3"),
		field == "groupfriendlytag", r = regex( line, rx, "\5 - \3 (\1)"),
		r = ""
	);
	return(r);
);

//Create JMP JSL script from options on the form.
BuildJMPJSL = function( {}, {txt},

	// Get inputs
	serverName = tb_server << GetText;
	querytype = rb_querytype << Get Selected;
	searchfield = rb_SearchField << Get Selected;
	cnformat = cb_cnformat << Get Selected;
	matchType = rb_matchtype << Get Selected;
	searchStrings = Words( TagList << Get Text, "\!N");
	calculationBasis = rb_calctype << GetSelected;
	startTime = TimeStart << GetText;
	endTime = TimeEnd << GetText;
	intervalTime = TimeInterval << GetText;
	If(SeparateInterval << Get(1) == 0,
		// Use the interval as the time step if there is no separate interval
		stepTime = intervalTime
	,
		stepTime = TimeStep << GetText
	);
	TableFormat = rb_tblformat << getSelected;
	
	oldcn = ns:map(searchStrings,
		function( {x}, Uppercase( Char( FieldFromLine( "tag", x || "\!N" ) ) ) )
	);
	
	newcn = ns:map(searchStrings,
		function( {x}, FieldFromLine( cnformat, x || "\!N" ) )
	);
	
	taggroups = ns:map(searchStrings,
		function( {x}, FieldFromLine( "group", x || "\!N" ) )
	);

	ColToSplit = If( 
		(querytype == "Interpolated Values" | querytype == "All Archived Values"), 
		{:value, :svalue, :status},
		{:value}
	);

	// Insert all JSL needed to produce the intended table into this Glue expression
	NewTblExpr = EvalExpr(Glue(
		NamesDefaultToHere(1);
		Message = "This script works only for JMP Desktop";
		// Requires the addin's namespace
		thisAddIn = "com.github.himanga.JMPOSIPITools";
		If(!Namespace Exists( Eval( thisAddIn ) || ".addinnamespace" ),
			ns = New Namespace( Eval( thisAddIn ) || ".addinnamespace" ),
			ns = Namespace( Eval( thisAddIn ) || ".addinnamespace" )
		);

		// Base URL to be used by all requests
		ns:baseURL = expr(tb_BaseURL << getText);
		// Max number if items returned used by all requests
		ns:maxRows = expr(num(tb_maxrows << getText));

		// Use the minumum of the user specified maxRows and the API Row limit as the number of rows to pull in a single request
		ns:maxCount = minimum(ns:maxRows, ns:APIRowLimit);
		// Gets the data server's web ID based on the user's preferences
		serverid = ns:DataServerIdRequest(expr(serverName));
	));

	// Get pointIDs
	If(searchField == "webID",
		InsertInto(NewTblExpr,
			evalExpr(pointIDs = expr(searchStrings))
		)
	,//else, need to request pointIDs
		InsertInto(NewTblExpr,
			evalExpr({pointIDs, pointNames} = ns:PointRequest(serverid, expr(oldcn), expr(searchfield), expr(matchType)))
		)
	);

	// Call a Table function depending on the query type
	tableRequestExpr = Match(querytype,
		"Point Info",
			Expr(dtLong = ns:GetPointAttributesTable(pointIDs)),
		"Snapshot Values",
			Expr(dtLong = ns:GetSnapshotValuesTable(pointIDs)),
		"All Archived Values",
			EvalExpr(dtLong = ns:GetArchiveValuesTable(pointIDs, pointNames, Expr(startTime), Expr(endTime))),
		"Interpolated Values",
			EvalExpr(dtLong = ns:GetInterpolatedValuesTable(pointIDs, pointNames, Expr(startTime), Expr(endTime), Expr(intervalTime))),
		"Average",
			EvalExpr(dtLong = ns:GetSummaryValuesTableWithStepTime(pointIDs, pointNames, "Average", Expr(calculationBasis), Expr(startTime), Expr(endTime), Expr(intervalTime), Expr(stepTime))),
		"Count",
			EvalExpr(dtLong = ns:GetSummaryValuesTableWithStepTime(pointIDs, pointNames, "Count", Expr(calculationBasis), Expr(startTime), Expr(endTime), Expr(intervalTime), Expr(stepTime))),
		"Max",
			EvalExpr(dtLong = ns:GetSummaryValuesTableWithStepTime(pointIDs, pointNames, "Maximum", Expr(calculationBasis), Expr(startTime), Expr(endTime), Expr(intervalTime), Expr(stepTime))),
		"Min",
			EvalExpr(dtLong = ns:GetSummaryValuesTableWithStepTime(pointIDs, pointNames, "Minimum", Expr(calculationBasis), Expr(startTime), Expr(endTime), Expr(intervalTime), Expr(stepTime))),
		"Population Standard Deviation",
			EvalExpr(dtLong = ns:GetSummaryValuesTableWithStepTime(pointIDs, pointNames, "PopulationStdDev", Expr(calculationBasis), Expr(startTime), Expr(endTime), Expr(intervalTime), Expr(stepTime))),
		"Range",
			EvalExpr(dtLong = ns:GetSummaryValuesTableWithStepTime(pointIDs, pointNames, "Range", Expr(calculationBasis), Expr(startTime), Expr(endTime), Expr(intervalTime), Expr(stepTime))),
		"Standard Deviation",
			EvalExpr(dtLong = ns:GetSummaryValuesTableWithStepTime(pointIDs, pointNames, "StdDev", Expr(calculationBasis), Expr(startTime), Expr(endTime), Expr(intervalTime), Expr(stepTime))),
		"Totals",
			EvalExpr(dtLong = ns:GetSummaryValuesTableWithStepTime(pointIDs, pointNames, "Total", Expr(calculationBasis), Expr(startTime), Expr(endTime), Expr(intervalTime), Expr(stepTime))),
		throw("Unknown query type")
	);
	InsertInto(NewTblExpr, NameExpr(tableRequestExpr));

	// Check if user's Max Rows is exceeded. For Point Info and Snapshot Value compare to row count.
	// For other queries compare to the most data for any one tag pulled.
	InsertInto(NewTblExpr, EvalExpr(
		if(!contains({"Point Info", "Snapshot Values"}, expr(querytype)),
			dtCount = dtLong << summary(group(:tag), "private");
			rowCount = colMax(column(dtCount, "N Rows"));
			close(dtCount, "nosave");
		,
			rowCount = nRows(dtLong)
		);
		if(rowCount >= ns:maxRows,
			NewWindow("Max Rows Exceeded", <<modal,
				TextBox(
					"Met or exceeded the maximum number of rows (" || char(ns:maxRows) ||
					") for this query. Increase the allowed maxrows or restrict the query. "||
					" Some results might be missing."
				)
			);
			dtLong << BringWindowToFront;
		);
		oldcn = expr(oldcn);
		oldcncorrected = oldcn;
	));

	If(cnformat != "tag",
		//Change Column Names 
		InsertInto(NewTblExpr, EvalExpr(
			newcn = expr(newcn);
			For( i = 1, i <= N Rows( dtLong ), i++,
				pos = Min( Loc( oldcncorrected, Uppercase( Column( dtLong, "tag" )[i]) ) );
				If( pos > 0,
					Column( dtLong, "tag" )[i] = newcn[pos]
				)
			)
		))
	);

	If( TableFormat == "Wide",
		// Make wide table
		InsertInto(NewTblExpr, EvalExpr(
			tableName = dtLong << getName;
			dtWide = dtLong << Split(
				Split By( :tag ),
				Split( expr(ColToSplit) ),
				Group( :time ),
				Remaining Columns( Drop All ),
				Sort by Column Property
			);
			close(dtLong, "nosave");
			dtWide << setName(tableName);
		));
		If(cb_tagtonotes << Get,
			// Save column properties
			InsertInto(NewTblExpr, EvalExpr(
				For( i = 1, i <= N Cols( dtWide ), i++,
					cn = Regex( Column( dtWide, i ) << Get Name, "((value )|(svalue )|(status ))?(.*)", "\5" );
					If( !Is Missing( cn ),
						pos = Min( Loc( oldcn, cn ) );
						If( pos > 0,
							Column( dtWide, i ) << Set Property( "PI tag", oldcncorrected[pos] );
							Column( dtWide, i ) << Set Property( "PI Original Column Name", Column( dtWide, i ) << Get Name );
							Column( dtWide, i ) << Set Property( "PI call type", expr(querytype) );
							Column( dtWide, i ) << Set Property( "PI interval", expr(intervalTime) );
							Column( dtWide, i ) << Set Property( "PI Server", expr(serverName) );
							If( contains({"Average", "Count", "Max", "Min", "Population Standard Deviation", "Range", "Standard Deviation", "Totals"}, expr(querytype)), 
								Column( dtWide, i ) << Set Property( "PI step", expr(stepTime));
								Column( dtWide, i ) << Set Property( "PI interval start offset", "-" || expr(stepTime));
								Column( dtWide, i ) << Set Property( "PI interval end offset", "");
							)
						);
					);
				)
			))
		)
	);
	Return( NameExpr(NewTblExpr) );
);

//Create JMP Live JSL script from options on the form.
BuildLiveJSL = function( {}, {txt},

	// Get inputs
	serverName = tb_server << GetText;
	querytype = rb_querytype << Get Selected;
	searchfield = rb_SearchField << Get Selected;
	cnformat = cb_cnformat << Get Selected;
	matchType = rb_matchtype << Get Selected;
	searchStrings = Words( TagList << Get Text, "\!N");
	calculationBasis = rb_calctype << GetSelected;
	startTime = TimeStart << GetText;
	endTime = TimeEnd << GetText;
	intervalTime = TimeInterval << GetText;
	If(SeparateInterval << Get(1) == 0,
		// Use the interval as the time step if there is no separate interval
		stepTime = intervalTime
	,
		stepTime = TimeStep << GetText
	);
	TableFormat = rb_tblformat << getSelected;
	
	oldcn = ns:map(searchStrings,
		function( {x}, Uppercase( Char( FieldFromLine( "tag", x || "\!N" ) ) ) )
	);
	
	newcn = ns:map(searchStrings,
		function( {x}, FieldFromLine( cnformat, x || "\!N" ) )
	);
	
	taggroups = ns:map(searchStrings,
		function( {x}, FieldFromLine( "group", x || "\!N" ) )
	);

	ColToSplit = If( 
		(querytype == "Interpolated Values" | querytype == "All Archived Values"), 
		{:value, :svalue, :status},
		{:value}
	);
	// If QueryType is not Point Info
	// Insert all JSL needed to produce the intended table into this Glue expression
	// Gets the data server WebId for the given serverName
	// Else enter a Message saying this is not valid for JMP Live
	if(querytype == "Point Info",
		NewTblExpr = Expr(Message = "Point Info is not valid for JMP Live";),
//---------------------------------------------------------------------------------------------------------------------
	// Common Procedures for all query types
//---------------------------------------------------------------------------------------------------------------------
		NewTblExpr = Expr(	
			NamesDefaultToHere(1);
			message = "This script works only for the JMP Live Server";
			// Requires the addin's namespace
			nsLiveName = "com.github.himanga.JMPOSIPITools.JMPLiveNameSpace";
			If(!Namespace Exists(nsLiveName),
			nsLive = New Namespace(nsLiveName),
			nsLive = Namespace(nsLiveName)
			);
			nsName = "com.github.himanga.JMPOSIPITools.addinnamespace";
			If(!Namespace Exists(nsName),
				ns = New Namespace(nsName),
				ns = Namespace(nsName)
			);
			nsLive:DataServerIdRequest = function({serverName},
			{DEFAULT LOCAL},
			params = associativeArray();
			params["name"] = serverName;
			params["selectedFields"] = "WebId";
			// https://docs.osisoft.com/bundle/pi-web-api-reference/page/help/controllers/dataserver/actions/getbyname.html
			result = nsLive:GetRequest("dataservers", params);
			if(!contains(result, "WebId"),
				throw("No data server found with name '"||params["name"] ||"'.")
			);
			return(result["WebId"])
			);
			// Sends a GET request to the endpoint with the specified parameters
			nsLive:GetRequest = Function({endpoint, queryParameters},
				{DEFAULT LOCAL},
				baseURL = ns:baseURL;
				if(!EndsWith(baseURL, "/"),
					baseURL ||= "/"
				);
				request = Expr( 
					New HTTP Request(
					URL(baseURL || endpoint),
					Method("GET"),
					QueryString(queryParameters),
					Username("%_UID_%"),
					Password("%_PWD_%"),
					Headers( {"Accept: application/json"} )
					) 
				);
				request = Eval( request );
				result = request << send;
				if(!(request << IsSuccess),
					errorMessage = "Error connecting to web API, do you have a bad URL or server name?";
					errorMessage ||= "\!NLast URL: " || (request << GetLastURL);
					errorMessage ||= "\!NWeb Request Status: " || (request << GetStatusMessage);
					//errorMessage ||= "\!NError from PI: " || try(char(parseJSON(result)["Errors"]), "");
					Throw(errorMessage);
				);
				return(parseJSON(result));
			);
			// Gets the data server WebId for the given serverName
			nsLive:DataServerIdRequest = function({serverName},
				{DEFAULT LOCAL},
				params = associativeArray();
				params["name"] = serverName;
				params["selectedFields"] = "WebId";
				// https://docs.osisoft.com/bundle/pi-web-api-reference/page/help/controllers/dataserver/actions/getbyname.html
				result = nsLive:GetRequest("dataservers", params);
				if(!contains(result, "WebId"),
					throw("No data server found with name '"||params["name"] ||"'.")
				);
				return(result["WebId"])
			);
			// Finds points by tag name or description and returns their WebIDs and names
			nsLive:PointRequest = Function({dataServerID, searchStrings, searchField, matchType},
				{DEFAULT LOCAL},
				if(!contains({"tag", "descriptor"}, searchField),
					throw("'searchField' must be one of \!"tag\!" or \!"descriptor\!" in 'ns:PointRequest'.")
				);
				if(!contains({"Exact", "Starts with", "Ends with", "Contains"}, matchType),
					throw("'matchType' must be one of \!"Exact\!", \!"Starts with\!", \!"Ends with\!" or \!"Contains\!" in 'ns:PointRequest'.")
				);

				// Add wildcards to searchString depending on matchType
				for(i=1, i<=NItems(searchStrings), i++,
					searchString = searchStrings[i];
					match(matchType,
						"Starts with", searchString = searchString || "*",
						"Ends with", searchString = "*" || searchString,
						"Contains", searchString = "*" || searchString || "*"
					);
					// Quote the searchString to allow white space
					searchString = "\!"" || searchString || "\!"";
					// Build the search query string
					// https://docs.osisoft.com/bundle/pi-web-api-reference/page/help/topics/pipoint-search-query-syntax.html
					searchString = "(" || searchField || ":" || searchString || ")";
					searchStrings[i] = searchString;
				);
				// Combine all individual queries with ORs
				searchQuery = ConcatItems(searchStrings, "OR");

				params = associativeArray();
				params["dataServerWebId"] = dataServerID;
				params["query"] = searchQuery;
				params["maxCount"] = ns:maxCount;
				params["startIndex"] = 0;
				pointIDs = {};
				pointNames = {};
				While(1,
					// Repeat this query in batches of ns:maxCount number of points
					// https://docs.osisoft.com/bundle/pi-web-api-reference/page/help/controllers/point/actions/getpointsbysearch.html
					result = nsLive:GetRequest("points/search", params);

					items = result["Items"];
					for(i=1, i<=nItems(items), i++,
						insertInto(pointIDs, items[i]["WebId"]);
						insertInto(pointNames, items[i]["Name"]);
					);

					// Break if there are fewer points than the maximum allowed by the API or if the user's limit is reached
					if(nItems(items) < ns:maxCount | nItems(pointIDs) >= ns:maxRows,
						break()
					);
					// Start the next query at the next index
					params["startIndex"] += ns:maxCount;
				);

				if(!nItems(pointIDs), throw("No matching PI points were found"));

				return(pointIDs, pointNames)
			);
			// Parses dates of the format returned by the web API and returns a local time
			nsLive:ParseDateString = Function({dateString},
				{DEFAULT LOCAL},
				If(EndsWith(dateString, "Z"),
					// Z suffix means UTC time. Convert to local.
					dateString = Left(dateString, Length(dateString) - 1);
					localTime = ParseDate(dateString) + nsLive:GetLocalTimeZoneDifference();
					Return(localTime)
				,
					Return(ParseDate(dateString))
				);
			);

			nsLive:GetLocalTimeZoneDifference = Function({},
			{DEFAULT LOCAL},
			try(
				return(nsLive:timeDifference)
			,
				request = Expr( NewHTTPRequest(
					URL(ns:baseURL),
					Method("GET"),
					UserName("%_UID_%"),
					password("%_PWD_%"),
					Headers({"Accept: application/json"})
				));
				request = Eval(request);
				request << Send;
				headers = request << Get Response Headers();
				utc = headers["date"];
				timeDifference = Round((Today() - utc)/InHours(1)) * InHours(1);
				// Store the time difference so this query only happens once
				nsLive:timeDifference = timeDifference;
				return(timeDifference)
				)
			);
		);
	//---------------------------------------------------------------------------------------------------------------------------------
	// Query specific procedures
	//----------------------------------------------------------------------------------------------------------------------------------
		ValidExpr = expr(
			nsLive:GetValidStartAndEndTimes = function({startTime, endTime, interval, endInclusive=1},
				{DEFAULT LOCAL},
				{interval} = nsLive:PiDurationToSeconds(evalList({interval}));
				{startTime, endTime} = nsLive:PiTimeToTimestamp(evalList({startTime, endTime}), 1);
				totalTime = endTime-startTime;
				newStartTime = startTime;
				newTimes = {};
				while(1,
					newEndTime = newStartTime + (interval * (ns:maxCount - 1 + endInclusive));
					newTimeRange = evalList({nsLive:ToDateString(newStartTime), nsLive:ToDateString(newEndTime)});
					insertInto(newTimes, evalList({newTimeRange}));
					if(newEndTime-startTime >= totalTime,
						// Make sure the last time is exactly the original endTime
						newTimes[nItems(newtimes)][2] = nsLive:ToDateString(endTime);

						// If the final range's duration is less than the interval, remove it from the list of ranges
						If(endInclusive & endTime - newStartTime <= interval,
							removeFrom(newTimes, -1)
						);
						Break()
					);
					newStartTime = newEndTime + if(endInclusive, 0, interval);
				);
				Return(newTimes)
			);
		);
		// Converts PI durations to a length in seconds. e.g. 1h-30m = 1800s
		durationExpr = expr(nsLive:PiDurationToSeconds = function({piDurations},
				{DEFAULT LOCAL},
				piTimes = {};
				for(i=1, i<=nItems(piDurations), i++,
					// add each duration to a known time so the two can be compared
					insertInto(piTimes, "t+"||piDurations[i]);
				);
				insertInto(piTimes, "t");
				times = nsLive:PiTimeToTimestamp(piTimes, parseTimestamp=1);
				t_time = times[NItems(times)];
				durations = {};
				for(i=1, i<nItems(times), i++,
					InsertInto(durations, times[i]-t_time)
				);
				return(durations)
			);
		);

		PiTimeTimeStampExpr = Expr(	
			// Converts PI times to a timestamp that JMP can use
			// Optionally parse the timestamp into a JMP datetime
			nsLive:PiTimeToTimestamp = function({piTimes, parseTimestamp=0},
				{DEFAULT LOCAL},
				timestamps = {};
				// Do an empty calculation at a each time just to get a Timestamp back
				params = ["expression" => 1, "selectedFields" => "Items.Timestamp"];
				for(i=1, i<=nItems(piTimes), i++,
					params["time"] = piTimes[i];
					result = nsLive:GetRequest("calculation/times/", params);
					ts = result["Items"][1]["Timestamp"];
					if(parseTimestamp,
						ts = nsLive:ParseDateString(ts)
					);
					InsertInto(timestamps, ts);
				);
				Return(timestamps)
			);
		);
		ExtractExpr = Expr(
			/* Gets a comma separated list of statuses from a result like 
			["Timestamp" => "2022-10-14T18:29:23Z",
			"UnitsAbbreviation" => "",
			"Good" => true, "Questionable" => false,
			"Substituted" => false,
			"Annotated" => false,
			"Value" => 98.22586]
			*/
			nsLive:ExtractStatus = Function({result},
				{DEFAULT LOCAL},
				statuses = {};
				/* Sometimes Value comes back like below and indicates a status
				"Value": {
					"Name": "Shutdown",
					"Value": 254,
					"IsSystem": true
				}
				*/
				If(IsAssociativeArray(result["Value"]) & contains(result["Value"], "Name"),
					InsertInto(statuses, result["Value"]["Name"])
				);
				keys = {"Good", "Questionable", "Substituted", "Annotated"};
				For(i=1, i<=nItems(keys), i++,
					If(result[keys[i]], InsertInto(statuses, keys[i]))
				);
				Return(ConcatItems(statuses, ","))
			);
		);
		DateStringExpr = Expr(
			// Converts a JMP date to a UTC datestring
			nsLive:ToDateString = Function({date},
				{DEFAULT LOCAL},
				utcDate = date - nsLive:GetLocalTimeZoneDifference();
				datestring = FormatDate(utcDate, "yyyy-mm-ddThh:mm:ss");
				Return(datestring || "Z")
			);
		);
		InterpolatedValuesExpr = Expr(
			// Get a list of interpolated values for the given pointID for all ranges provided
			// Example ranges: {{startdate1, enddate1}, {startdate2, enddate2}}
			// https://docs.osisoft.com/bundle/pi-web-api-reference/page/help/controllers/stream/actions/getinterpolated.html
			nsLive:GetInterpolatedValues = function({pointID, ranges, interval},
				{DEFAULT LOCAL},
				parameters = AssociativeArray();
				parameters["selectedFields"] = "Items";
				parameters["interval"] = interval;

				endpoint = "streams/" || pointID || "/interpolated";
				interpolatedValues = {};
				for(i=1, i<=nItems(ranges), i++,
					parameters["startTime"] = ranges[i][1];
					parameters["endTime"] = ranges[i][2];
					result = nsLive:GetRequest(endpoint, parameters);
					items = result["Items"];
					InsertInto(interpolatedValues, items);

					// Break if the user's limit is reached
					If(nItems(interpolatedValues) >= ns:maxRows,
						Break()
					);
				);
				Return(interpolatedValues)
			);
		);
		InterpolatedTableExpr = expr(
			// Get a table of interpolated values for each point in pointIDs between start and end times at the specified sampling interval
			nsLive:GetInterpolatedValuesTable = function({pointIDs, pointNames, startTime, endTime, interval},
				{DEFAULT LOCAL},
				dt = NewTable("Interpolated Values",
					NewColumn( "tag", Character),
					NewColumn( "time",  Numeric, Format("m/d/y h:m:s"), InputFormat("m/d/y h:m:s")),
					NewColumn( "value", Numeric),
					NewColumn( "svalue", Character),
					NewColumn( "status", Character)
				);

				ranges = nsLive:GetValidStartAndEndTimes(startTime, endTime, interval, endInclusive=0);

				For(i=1, i<=NItems(pointIDs), i++,
					interpolatedValues = nsLive:GetInterpolatedValues(pointIDs[i], ranges, interval);
					pointName = pointNames[i];
					For(j=1, j<=nItems(interpolatedValues), j++,
						result = interpolatedValues[j];
						row = Eval(EvalExpr(
							{
								tag = Expr(pointName),
								time = Expr(nsLive:ParseDateString(result["Timestamp"])),
								status = Expr(nsLive:ExtractStatus(result))
							}
						));
						// Add Value to value or svalue depending on type
						If(IsString(result["Value"]),
							InsertInto(row, EvalExpr(svalue = Expr(result["Value"])))
						,IsNumber(result["Value"]),
							InsertInto(row, EvalExpr(value = Expr(result["Value"])))
						);
						dt << AddRows(row);
					);
				);
				return(dt)
			);
		);
		SnapshotExpr = Expr(
			// Get a table of snapshot values for each point in pointIDs
			// https://docs.osisoft.com/bundle/pi-web-api-reference/page/help/controllers/streamset/actions/getendadhoc.html
			nsLive:GetSnapshotValuesTable = function({pointIDs},
				nsLive:BuildTableFromPointStreamSets(pointIDs, "end", [=>], "Snapshot Values")
			);
		);
		BuildTableExpr = Expr(
			// Common functionality for point stream endpoints to build a data table
			// with tag, time, value, svalue, and status info for all points in pointIDs
			// Uses adhoc endpoints of streamset to do a single bulk request rather than several individual requests
			// https://docs.osisoft.com/bundle/pi-web-api-reference/page/help/controllers/streamset.html
			nsLive:BuildTableFromPointStreamSets = function({pointIDs, streamEndpoint, parameters, title},
				{DEFAULT LOCAL},
				dt = NewTable(title,
					NewColumn( "tag", Character),
					NewColumn( "time",  Numeric, Format("m/d/y h:m:s"), InputFormat("m/d/y h:m:s")),
					NewColumn( "value", Numeric),
					NewColumn( "svalue", Character),
					NewColumn( "status", Character)
				);
				
				If(!StartsWith(streamEndpoint, "/"), streamEndpoint = "/" || streamEndpoint);
				endpoint = "streamsets" || streamEndpoint;
				parameters["webId"] = pointIDs; // Pass in a list to make multiple webId parameters
				parameters["selectedFields"] = "Items";
				result = nsLive:GetRequest(endpoint, parameters);
				points = result["Items"];
				For(i=1, i<=NItems(points), i++,
					point = points[i];
					// Get the list of all results for the point
					If(Contains(point, "Items"),
						pointResults = point["Items"]
					,// else a single item
						pointResults = EvalList({point["Value"]})
					);

					// Add rows for all results for the point
					For(j=1, j<=NItems(pointResults), j++,
						pointResult = pointResults[j];
						row = Eval(EvalExpr(
							{
								tag = Expr(point["Name"]),
								time = Expr(nsLive:ParseDateString(pointResult["Timestamp"])),
								status = Expr(nsLive:ExtractStatus(pointResult))
							}
						));
						// Add Value to value or svalue depending on type
						If(IsString(pointResult["Value"]),
							InsertInto(row, EvalExpr(svalue = Expr(pointResult["Value"])))
						,IsNumber(pointResult["Value"]),
							InsertInto(row, EvalExpr(value = Expr(pointResult["Value"])))
						);
						dt << AddRows(row);
					)
				);
				return(dt)
			);
		);
		SummaryValues = expr(
			// Get a list of summary values for the given pointID for all ranges provided
			// Example ranges: {{startdate1, enddate1}, {startdate2, enddate2}}
			// https://docs.osisoft.com/bundle/pi-web-api-reference/page/help/controllers/stream/actions/getsummary.html
			nsLive:GetSummaryValues = function({pointID, ranges, interval, summaryType, calculationBasis},
				{DEFAULT LOCAL},
				parameters = AssociativeArray();
				parameters["selectedFields"] = "Items.Value";
				parameters["summaryType"] = summaryType;
				parameters["calculationBasis"] = calculationBasis;
				parameters["summaryDuration"] = interval;
				parameters["timeType"] = "MostRecentTime";

				endpoint = "streams/" || pointID || "/summary";
				summaryValues = {};
				for(i=1, i<=nItems(ranges), i++,
					parameters["startTime"] = ranges[i][1];
					parameters["endTime"] = ranges[i][2];
					result = nsLive:GetRequest(endpoint, parameters);
					items = result["Items"];
					InsertInto(summaryValues, items);

					// Break if the user's limit is reached
					If(nItems(summaryValues) >= ns:maxRows,
						Break()
					);
				);
				Return(summaryValues)
			);	
		);
		StepSummaryValues = Expr(
			// Get a table of summary values for each point in pointIDs where a stepTime is provided.
			// The rows of the table should be from startTime to endTime with increments of stepTime duration.
			// The summary statistics should be calculated from each of these times (t) from t-interval to t
			nsLive:GetSummaryValuesTableWithStepTime = Function({pointIDs, pointNames, summaryType, calculationBasis, startTime, endTime, interval, stepTime},
				{DEFAULT LOCAL},

				// If the step time and interval are the same, it's as if there is no step time
				If(interval == stepTime,
					Return(nsLive:GetSummaryValuesTable(pointIDs, pointNames, summaryType, calculationBasis, startTime, endTime, interval))
				);

				if(calculationBasis != "TimeWeighted", throw("Step time is only supported with the 'TimeWeighted' calculation basis."));

				// Get a table of intended times from startTime to endTime in stepTime increments
				{intervalSeconds, stepTimeSeconds} = nsLive:PiDurationToSeconds(evalList({interval, stepTime}));
				{startTimeSeconds, endTimeSeconds} = nsLive:PiTimeToTimestamp(evalList({startTime, endTime}), 1);
				dtSummary = AsTable((startTimeSeconds::endTimeSeconds::stepTimeSeconds)`);
				column(dtSummary, 1) << setName("time") << setDataType(Numeric, Format("m/d/y h:m:s"));

				// Repeat summary value requests with the specified interval at different offsets
				// to get summary values at all times in the above table
				gcd = ns:GreatestCommonDivisor(intervalSeconds, stepTimeSeconds);
				nOffsets = intervalSeconds / gcd;
				for(i=1, i<=nOffsets, i++,
					offsetStartTime = ns:ToDateString(startTimeSeconds - gcd * i);
					// Get summary values for the offset start time
					dtTemp = nsLive:GetSummaryValuesTable(pointIDs, pointNames, "Average", "TimeWeighted", offsetStartTime, endTime, interval, private=1);
					// Join the summary values into the table of times
					dtJoin = dtSummary << Join(
						With(dtTemp),
						Merge Same Name Columns,
						Match Flag( 0 ),
						By Matching Columns( :time = :time ),
						Drop multiples( 0, 0 ),
						Include Nonmatches( 1, 0 ),
						Preserve main table order( 1 )
					);
					close(dtSummary, "nosave");
					close(dtTemp, "nosave");
					dtSummary = dtJoin;
				);

				dtSummary << setName("Summary Values - " || summaryType);
				dtSummary << Sort(
					By( :tag ),
					Order( Ascending ),
					ReplaceTable
				);
				dtSummary << newDataView;
				Return(dtSummary)
			);	
		);
		SummaryTable = Expr(
			// Get a table of summary values for each point in pointIDs
			nsLive:GetSummaryValuesTable = Function({pointIDs, pointNames, summaryType, calculationBasis, startTime, endTime, interval, private=0},
				{DEFAULT LOCAL},
				eval(evalExpr(
					dt = NewTable("Summary Values - " || summaryType,
						NewColumn( "tag", Character),
						NewColumn( "time",  Numeric, Format("m/d/y h:m:s"), InputFormat("m/d/y h:m:s")),
						NewColumn( "value", Numeric),
						expr(if(private, "private"))
					);
				));

				ranges = nsLive:GetValidStartAndEndTimes(startTime, endTime, interval, endInclusive=1);

				For(i=1, i<=NItems(pointIDs), i++,
					pointName = pointNames[i];
					pointResults = nsLive:GetSummaryValues(pointIDs[i], ranges, interval, summaryType, calculationBasis);
					For(j=1, j<=NItems(pointResults), j++,
						pointResult = pointResults[j];
						row = Eval(EvalExpr(
							{
								tag = Expr(pointName),
								time = Expr(nsLive:ParseDateString(pointResult["Value"]["Timestamp"])),
								value = Expr(pointResult["Value"]["Value"])
							}
						));
						dt << AddRows(row);
					);
				);
				Return(dt)
			);	
		);
		ArchiveExpr = Expr(
			// Get an list of archive values for the given pointID between start and end times
			// https://docs.osisoft.com/bundle/pi-web-api-reference/page/help/controllers/stream/actions/getrecorded.html
			nsLive:GetArchiveValues = function({pointID, startTime, endTime},
				{DEFAULT LOCAL},
				parameters = AssociativeArray();
				parameters["selectedFields"] = "Items";
				parameters["maxCount"] = ns:maxCount;
				parameters["startTime"] = startTime;
				parameters["endTime"] = endTime;

				endpoint = "streams/" || pointID || "/recorded";
				archiveValues = {};
				While(1,
					result = nsLive:GetRequest(endpoint, parameters);
					items = result["Items"];
					InsertInto(archiveValues, items);

					// Break if there are fewer points than the maximum allowed by the API or if the user's limit is reached
					If(nItems(items) < ns:maxCount | nItems(archiveValues) >= ns:maxRows,
						Break()
					);
					// Otherwise, increase the startTime parameter to be the last end time + 1ms so that the last time is not included again
					lastTime = items[nItems(items)]["Timestamp"] || "+1ms";
					parameters["startTime"] = lastTime;
				);
				Return(archiveValues)
			);
		);
		ArchiveTableExpr = Expr(
			// Get a table of archive values for each point in pointIDs between start and end times
			nsLive:GetArchiveValuesTable = function({pointIDs, pointNames, startTime, endTime},
				{DEFAULT LOCAL},
				dt = NewTable("Archive Values",
					NewColumn( "tag", Character),
					NewColumn( "time",  Numeric, Format("m/d/y h:m:s"), InputFormat("m/d/y h:m:s")),
					NewColumn( "value", Numeric),
					NewColumn( "svalue", Character),
					NewColumn( "status", Character)
				);

				// Fix start and end times so all requests use the same times where e.g. if the endTime is *
				if(nItems(pointIDs) > 1,
					{fixedStartTime, fixedEndTime} = nsLive:PiTimeToTimestamp(evalList({startTime, endTime}));
				,
					fixedStartTime = startTime;
					fixedEndTime = endTime;
				);

				For(i=1, i<=NItems(pointIDs), i++,
					archiveValues = ns:GetArchiveValues(pointIDs[i], fixedStartTime, fixedEndTime);
					pointName = pointNames[i];
					For(j=1, j<=nItems(archiveValues), j++,
						result = archiveValues[j];
						row = Eval(EvalExpr(
							{
								tag = Expr(pointName),
								time = Expr(ns:ParseDateString(result["Timestamp"])),
								status = Expr(ns:ExtractStatus(result))
							}
						));
						// Add Value to value or svalue depending on type
						If(IsString(result["Value"]),
							InsertInto(row, EvalExpr(svalue = Expr(result["Value"])))
						,IsNumber(result["Value"]),
							InsertInto(row, EvalExpr(value = Expr(result["Value"])))
						);
						dt << AddRows(row);
					);
				);
				return(dt)
			);
		);
		AggStatus = or(querytype=="Average",
						querytype=="Count",
						querytype=="Max",
						querytype=="Min",
						querytype=="Population Standard Deviation",
						querytype=="Range",
						querytype=="Standard Deviation",
						querytype=="Totals");

		NewQueryType =if(AggStatus,"Aggregate Values",querytype);

		// Calls and inserts the specific procedures required for the query type
		Match(NewQueryType,
		"Snapshot Values",
			InsertInto(NewTblExpr,NameExpr(ExtractExpr));
			InsertInto(NewTblExpr,NameExpr(SnapshotExpr));
			InsertInto(NewTblExpr, NameExpr(BuildTableExpr));,
		"Interpolated Values",
			InsertInto( NewTblExpr,NameExpr(ValidExpr));
			InsertInto( NewTblExpr,NameExpr(durationExpr));
			InsertInto( NewTblExpr,NameExpr(PiTimeTimeStampExpr));
			InsertInto( NewTblExpr,NameExpr(ExtractExpr));
			InsertInto( NewTblExpr,NameExpr(DateStringExpr));
			InsertInto( NewTblExpr,NameExpr(InterpolatedValuesExpr));
			InsertInto( NewTblExpr, NameExpr(InterpolatedTableExpr)),
		"Aggregate Values",
			InsertInto( NewTblExpr,NameExpr(DateStringExpr));
			InsertInto( NewTblExpr,NameExpr(PiTimeTimeStampExpr));
			InsertInto( NewTblExpr,NameExpr(ValidExpr));
			InsertInto( NewTblExpr,NameExpr(durationExpr));
			InsertInto(NewTblExpr, NameExpr(SummaryValues));
			InsertInto(NewTblExpr, NameExpr(StepSummaryValues));
			InsertInto(NewTblExpr, NameExpr(SummaryTable)),
		"All Archived Values",
			InsertInto( NewTblExpr,NameExpr(DateStringExpr));
			InsertInto( NewTblExpr,NameExpr(PiTimeTimeStampExpr));
			InsertInto(NewTblExpr,NameExpr(ExtractExpr));
			InsertInto(NewTblExpr,NameExpr(ArchiveExpr));
			InsertInto(NewTblExpr,NameExpr(ArchiveTableExpr));,
		throw("Unknown query type")
		);
		InsertInto( NewTblExpr , Eval Expr(
			// Base URL to be used by all requests
			ns:baseURL = expr(tb_BaseURL << getText);
			// Max number if items returned used by all requests
			ns:maxRows = expr(num(tb_maxrows << getText));
			ns:APIRowLimit = 150000;
			// Use the minumum of the user specified maxRows and the API Row limit as the number of rows to pull in a single request
			ns:maxCount = minimum(ns:maxRows, ns:APIRowLimit);
			// Gets the data server's web ID based on the user's preferences
			serverid = nsLive:DataServerIdRequest(expr(serverName));
			);
		);

		// Get pointIDs
		If(searchField == "webID",
			InsertInto(NewTblExpr,
				evalExpr(pointIDs = expr(searchStrings))
			)
		,//else, need to request pointIDs
			InsertInto(NewTblExpr,
				evalExpr({pointIDs, pointNames} = nsLive:PointRequest(serverid, expr(oldcn), expr(searchfield), expr(matchType)))
			)
		);

		// Call a Table function depending on the query type
		tableRequestExpr = Match(querytype,
			"Point Info",
				Expr(dtLong = nsLive:GetPointAttributesTable(pointIDs)),
			"Snapshot Values",
				Expr(dtLong = nsLive:GetSnapshotValuesTable(pointIDs);
				tableName = dtLong << getName;),
			"All Archived Values",
				EvalExpr(dtLong = nsLive:GetArchiveValuesTable(pointIDs, pointNames, Expr(startTime), Expr(endTime)););
				Expr(tableName = dtLong << getName;),
			"Interpolated Values",
				EvalExpr(dtLong = nsLive:GetInterpolatedValuesTable(pointIDs, pointNames, Expr(startTime), Expr(endTime), Expr(intervalTime))),
			"Average",
				EvalExpr(dtLong = nsLive:GetSummaryValuesTableWithStepTime(pointIDs, pointNames, "Average", Expr(calculationBasis), Expr(startTime), Expr(endTime), Expr(intervalTime), Expr(stepTime))),
			"Count",
				EvalExpr(dtLong = nsLive:GetSummaryValuesTableWithStepTime(pointIDs, pointNames, "Count", Expr(calculationBasis), Expr(startTime), Expr(endTime), Expr(intervalTime), Expr(stepTime))),
			"Max",
				EvalExpr(dtLong = nsLive:GetSummaryValuesTableWithStepTime(pointIDs, pointNames, "Maximum", Expr(calculationBasis), Expr(startTime), Expr(endTime), Expr(intervalTime), Expr(stepTime))),
			"Min",
				EvalExpr(dtLong = nsLive:GetSummaryValuesTableWithStepTime(pointIDs, pointNames, "Minimum", Expr(calculationBasis), Expr(startTime), Expr(endTime), Expr(intervalTime), Expr(stepTime))),
			"Population Standard Deviation",
				EvalExpr(dtLong = nsLive:GetSummaryValuesTableWithStepTime(pointIDs, pointNames, "PopulationStdDev", Expr(calculationBasis), Expr(startTime), Expr(endTime), Expr(intervalTime), Expr(stepTime))),
			"Range",
				EvalExpr(dtLong = nsLive:GetSummaryValuesTableWithStepTime(pointIDs, pointNames, "Range", Expr(calculationBasis), Expr(startTime), Expr(endTime), Expr(intervalTime), Expr(stepTime))),
			"Standard Deviation",
				EvalExpr(dtLong = nsLive:GetSummaryValuesTableWithStepTime(pointIDs, pointNames, "StdDev", Expr(calculationBasis), Expr(startTime), Expr(endTime), Expr(intervalTime), Expr(stepTime))),
			"Totals",
				EvalExpr(dtLong = nsLive:GetSummaryValuesTableWithStepTime(pointIDs, pointNames, "Total", Expr(calculationBasis), Expr(startTime), Expr(endTime), Expr(intervalTime), Expr(stepTime))),
			throw("Unknown query type")
		);
		InsertInto(NewTblExpr, NameExpr(tableRequestExpr));

		// Check if user's Max Rows is exceeded. For Point Info and Snapshot Value compare to row count.
		// For other queries compare to the most data for any one tag pulled.
		InsertInto(NewTblExpr, EvalExpr(
			if(!contains({"Point Info", "Snapshot Values"}, expr(querytype)),
				dtCount = dtLong << summary(group(:tag), "private");
				rowCount = colMax(column(dtCount, "N Rows"));
				close(dtCount, "nosave");
			,
				rowCount = nRows(dtLong)
			);
			if(rowCount >= ns:maxRows,
				NewWindow("Max Rows Exceeded", <<modal,
					TextBox(
						"Met or exceeded the maximum number of rows (" || char(ns:maxRows) ||
						") for this query. Increase the allowed maxrows or restrict the query. "||
						" Some results might be missing."
					)
				);
				dtLong << BringWindowToFront;
			);
			oldcn = expr(oldcn);
			oldcncorrected = oldcn;
		));

		If(cnformat != "tag",
			//Change Column Names 
			InsertInto(NewTblExpr, EvalExpr(
				newcn = expr(newcn);
				For( i = 1, i <= N Rows( dtLong ), i++,
					pos = Min( Loc( oldcncorrected, Uppercase( Column( dtLong, "tag" )[i]) ) );
					If( pos > 0,
						Column( dtLong, "tag" )[i] = newcn[pos]
					)
				)
			))
		);

		If( TableFormat == "Wide",
			// Make wide table
			InsertInto(NewTblExpr, EvalExpr(
				tableName = dtLong << getName;
				dtWide = dtLong << Split(
					Split By( :tag ),
					Split( expr(ColToSplit) ),
					Group( :time ),
					Remaining Columns( Drop All ),
					Sort by Column Property
				);
				close(dtLong, "nosave");
				dtWide << setName(tableName);
			));
			If(cb_tagtonotes << Get,
				// Save column properties
				InsertInto(NewTblExpr, EvalExpr(
					For( i = 1, i <= N Cols( dtWide ), i++,
						cn = Regex( Column( dtWide, i ) << Get Name, "((value )|(svalue )|(status ))?(.*)", "\5" );
						If( !Is Missing( cn ),
							pos = Min( Loc( oldcn, cn ) );
							If( pos > 0,
								Column( dtWide, i ) << Set Property( "PI tag", oldcncorrected[pos] );
								Column( dtWide, i ) << Set Property( "PI Original Column Name", Column( dtWide, i ) << Get Name );
								Column( dtWide, i ) << Set Property( "PI call type", expr(querytype) );
								Column( dtWide, i ) << Set Property( "PI interval", expr(intervalTime) );
								Column( dtWide, i ) << Set Property( "PI Server", expr(serverName) );
								If( contains({"Average", "Count", "Max", "Min", "Population Standard Deviation", "Range", "Standard Deviation", "Totals"}, expr(querytype)), 
									Column( dtWide, i ) << Set Property( "PI step", expr(stepTime));
									Column( dtWide, i ) << Set Property( "PI interval start offset", "-" || expr(stepTime));
									Column( dtWide, i ) << Set Property( "PI interval end offset", "");
								)
							);
						);
					)
				))
			)
		);
		InsertInto( NewTblExpr , Expr(
			dt = new Table("TempValueToMakeJMPLiveWork");
			dt = DataTable(tableName);
			Note To Users = "\[
			
			Add your script after these comments.
			 - Change any data table references to 'dt' as in the example below
			 - Make sure dt; is the last line of the script
			
			Example:
			dt:value SINUSOID << Set Property( "Spec Limits", {LSL( -50 ), USL( 50 ), Show Limits( 0 )} );
			dt;
			]\";
			dt;
		));
		
		Return( NameExpr(NewTblExpr) );
	);
);
//flag to output a bunch of status info to the log file
debug = 0;

//window box, all code is inside this box
nw = New Window( "PI Web API Query Builder",

	//box to hold spacers on left and right side of data
	H List Box ( 
		
		//spacer on left side of window
		Spacer Box( Size( 12, 12) ),
	
		//box to hold heading above all other contents
		V List Box(
			Text Box( "Get Data from a PI Server ", << Set Width( 500 ),  << Set Font Size( 20 ) ), 
			Spacer Box( Size( 12, 12 ) ),
			
			H List Box(
			
				V List Box(
					
					//PI Server Name
					sbDefault(), 
					
					stdtxtInput( varname = "tb_server",
						descmsg = "Server Name", initval = ns:UserPref["PI_Server"], 
						helpmsg = "Enter the name of the PI Web Server." ||
							"\!N\!NChange the default value using the User Preferences below." ),

					//PI Web API Base URL
					sbDefault(),

					hlbURL = stdtxtInput( varname = "tb_BaseURL",
						descmsg = "Web API Base URL", initval = ns:UserPref["Base_Url"], 
						helpmsg = "Enter the base URL to access the PI Web API." ||
							"\!N\!NChange the default value using the User Preferences below." );
					hlbURL[TextEditBox(1)] << setWidth(250);
					hlbURL,
					
					//Max number of values
					sbDefault(),  
					
					stdtxtInput( varname = "tb_maxrows",
						descmsg = "Max rows", 
						initval = ns:UserPref["Max_Rows"], 
						helpmsg = "Enter the maximum number of values to return per tag." ),
					
					//Recall Connection
					window:connections = Eval List({"Default;" || ns:UserPref["PI_Server"] || ";" ||
								ns:UserPref["Base_Url"]}) || words(ns:UserPref["Connection_List"], "\!N");
					stdcbInput(
						descmsg = "Recall Connection", 
						varname = "cb_connpresets",
						values = transform each( {line}, window:connections, {w},
							w = words(line, ";");
							w[1] || " (" || w[2] || ")"
						),
						fn = function( {this, index},
							conn = filter each( {line}, window:connections, {w},
								w = words(line, ";");
								try( this << Get Selected == w[1] || " (" || w[2] || ")", 1)
							)[1];
							tb_server << Set Text(words(conn, ";")[2]);
							tb_BaseURL << Set Text(words(conn, ";")[3]);
							UpdateOutput();
						),
						helpmsg = "Select one of the conections defined in your preferences."
					),
					
					//radio buttons to choose the type of query
					panelbox("Query Types",
						rb_querytype = radio box({ "Point Info", "Snapshot Values", "All Archived Values", 
							"Interpolated Values", "Average", "Count", "Max", "Min", 
							"Population Standard Deviation", "Range", "Standard Deviation", "Totals"},
							DefaultTableFormat();
							UpdateOutput();
						),
					),
					//Start, end, and interval times
					lb_querytimes = V List Box(
						
						stdcbInput(
							descmsg = "Presets: ", 
							varname = "cb_times",
							values = "Custom",
							fn = function( {this, index}, 
								preset = try( cb_times << Get Selected; );
								try(	if( !( preset == "Custom" ),
										nms = ns:map(PresetTimes, function({x}, x[1] == preset) );
										TimeStart << Set Text( PresetTimes[Loc(Matrix(nms))][1][2] );
										TimeEnd << Set Text( PresetTimes[Loc(Matrix(nms))][1][3] );
										TimeInterval << Set Text( PresetTimes[Loc(Matrix(nms))][1][4] );
										SeparateInterval << Set All( PresetTimes[Loc(Matrix(nms))][1][5] );
										TimeStep << Set Text( PresetTimes[Loc(Matrix(nms))][1][6] );
									);
									UpdateOutput();
								);
							),
							helpmsg = "Examples to demonstrate a few common time configurations."
						),
						
						lb_starttime = V List Box(
							sbDefault(),
							stdtxtInput( varname = "TimeStart",
								descmsg = "Start Time", initval = "t - 1d", 
								helpmsg = "Enter a time in any PI Format, or example 'y-1d' or '2017-01-01'.",
								fn = function( {this}, cb_times << Set ( 1 ); UpdateOutput(); ) ),
						),
						lb_endtime = V List Box(
							sbDefault(),
							stdtxtInput( varname = "TimeEnd",
								descmsg = "End Time", initval = "*", 
								helpmsg = "Enter a time in any PI Format, or example 'y-1d' or '2017-01-01'.",
								fn = function( {this}, cb_times << Set ( 1 ); UpdateOutput(); ) ),
						),
						
						lb_intervaltime = V List Box(
							sbDefault(),
							stdtxtInput( varname = "TimeInterval",
								descmsg = "Interval", initval = "1h", 
								helpmsg = "The amount of time pertaining to each row." ||
									"\!N\!NEnter a time interval in any PI Format, for example '1h'.",
								fn = function( {this}, cb_times << Set ( 1 ); UpdateOutput(); ) ),
						),
						lb_steptime = V List Box(
							sbDefault(),
							V List Box(
								H List Box(
									
									V Center Box( 
										H List Box(
											SeparateInterval = Check Box( 
												"Set step time separate from interval time.", 
												<< SetFunction( function( {this}, cb_times << Set ( 1 ); UpdateOutput(); ) )
											),
											<<Set Width( 250 )
										)
									),
											
									V Center Box( bbHelp("Advanced, check this to run a query where the time period " ||
										"pertaining to each row is longer or shorter than the time between rows." ||
										"\!N\!NThis would allow 'moving averages', for example where the 10 minute " ||
										"average is updated every minute." ||
										"Step time determines how many rows will be in your data table.  Interval time " ||
										"determines how much time relates to each row." ||
										"\!N\!NIf you want a value at 1AM, 2AM, 3AM, then step time = 1h" ||
										"\!N\!NIf you want the 2AM value to include the average over the last two hours, then interval time = 2h"
									) )
								),
								lb_steptimesub = V List Box(
									sbDefault(),
									stdtxtInput( varname = "TimeStep",
										descmsg = "Step Time", initval = "1h", 
										helpmsg = "The time between each row." ||
											"\!N\!NEnter a time interval in any PI Format, for example '1h'.",
											fn = function( {this}, cb_times << Set ( 1 ); UpdateOutput(); ) ),
								)
							)
						)
					),
					
					lb_CalcBasis = H List Box(
						//radio buttons to choose the type of weighting for aggregated data
						pbCalcBasis = panelbox("Calculation Basis",
							rb_calctype = radio box({ "TimeWeighted", "EventWeighted", "TimeWeightedContinuous", 
							"TimeWeightedDiscrete", "EventWeightedExcludeMostRecentEvent",
							"EventWeightedExcludeEarliestEvent", "EventWeightedIncludeBothEnds" },
								UpdateOutput();
							),
						),
						bbHelp( "How should summarized values be calculated?  This makes a big difference " ||
							"when there are 10 archived values one hour with a small value and 1 archived value " ||
							"the next hour with a large value.", HelpType = "stdradio" )
					)
				),
				
				Spacer Box( Size( 24, 24 ) ),
				
				hsb_main = H List Box(
					V List Box(
					
						//radio buttons to choose whether to search for tag or description
						lb_searchfield = H List Box(
							panelbox("Search Field",
								rb_SearchField = radio box({ "tag", "descriptor", "webID"},
									UpdateOutput();
								),
							),
							bbHelp( "Search for tag names, descriptions, or point webIDs.", 
								HelpType = "stdradio" )
						),
						
						//List of Tags
						Spacer Box( Size( 12, 12 ) ),
						H List Box(
							tb_tagnameshead = Text Box( "Tag Names",
									<< Padding( Right( 5 ) ) ),
							bbHelp( "Enter a list of tag names or descriptions here, " ||
								"\!N\!NFor Example:" ||
								"\!Ntag01-AFA;My Tag Name" ||
								"\!N or:" ||
								"\!Ntag01-AFA;My Tag Name;Group 1" ),
							V Center Box( Mouse Box(
								Text Box( "Resize to Fit Window",
									<< Set Font Size ( 10 ),
									<< Font Color ( "blue" ),
									<< Padding( Left( 20 ) )
								),
								<< setTrackEnable( 1 ),
								<< setTrack( Function( {this, clickpt},
										this << setCursor( "Finger" ); /* button-up tracking - use the hand */
										If((clickpt[1] == -1 & clickpt[2] == -1 ),
											(this << child) << Set Font Style ("plain"),
											(this << child) << Set Font Style ("bold");
										)
								) ),
								<<SetClickEnable( 1 ),
								<<SetClick( Function( {this, clickpt, event},
										If(event == "Pressed", SizeTextBoxes() )
								) )
							))
						),
						Spacer Box( Size( 2, 2 ) ), 
						V List Box( 
							TagListsb = Scroll Box( size(400,400), flexible(1),
								TagList = Text Edit Box(
									"Sinusoid",
									<< Justify Text( Left ),
									//<< Set Width( 400 ),
									<< setNlines( 20 ),
									<< Set Wrap( 2000 ),
									<< SetFunction( function( {this}, 
										UpdateOutput(); 
									) ),
									<< User Resizable( {1, 1} );
								)
							)
						),
						Spacer Box( Size( 2, 2 ) ), 
						H List Box(
							V Center Box( Text Box( "Column Name Format: ") ),
							V Center Box( cb_cnformat = Combo Box( {
								"tag",
								"friendly",
								"friendlytag"
							},
								UpdateOutput();
							) ),
							V Center Box( bbHelp( "Choose how tags should be named in the resulting data table." ||
								"This determines the names in the 'tag' or 'expr' column in long tables, and " ||
								"column names in the wide format." ||
								"\!N\!NExample input in section above:" ||
								"\!Ntag01-AFA;My Tag Name;Group 1" ||
								"\!N\!NResults in these tag or column names:" ||
								"\!Ntag: tag01-AFA" ||
								"\!Nfriendly: My Tag Name" ||
								"\!Nfriendlytag: My Tag Name (tag01-AFA)"
							) )
						),
						
						//Save tag names in column notes
						Spacer Box( Size( 2, 2 ) ), 
						H List Box(
							cb_tagtonotes = Check Box( "Save tag names in column notes.", UpdateOutput() ),
							bbHelp("When checked tag names are saved under the 'notes' property of a column.  Find " ||
								"this under Column Info."
							)
						),
						/*
						//Group Columns
						Spacer Box( Size( 2, 2 ) ), 
						H List Box(
							cb_groupcols = Check Box( "Group columns", UpdateOutput() ),
							bbHelp("When checked columns are grouped together based on the group name specified " ||
								"in the list above.  There must be at least two tags per group."
							)
						),
						*/
						
						//radio buttons with examples, when selected the text in the formula edit box is modified
						Spacer Box( Size( 2, 2 ) ), 
						H List Box(
							lb_matchtype = H List Box(
								Panelbox("Tag Matching Type",
									rb_matchtype = radio box({"Exact", "Starts with", "Ends with", "Contains"},
										two_rb = rb_matchtype << get selected;
										if (two_rb == "Exact",
											SearchType = "Exact";
											two_rb == "Starts with",
											SearchType = "Starts with";
											two_rb == "Ends with",
											SearchType = "Ends with";
											two_rb == "Contains",
											SearchType = "Contains";
										);
										UpdateOutput();
									),
								),
								bbHelp( "Exact is the fastest but does not allow wildcards." ||
									"\!N\!NStarts with adds a '*' to the beginning of each line." ||
									"\!N\!NEnds with adds a '*' to the end of each line." ||
									"\!N\!NContains with adds a '*' to the beginning and end of each line.",
									HelpType = "stdradio"
								)
							),
							Spacer Box( Size( 24, 24 ) ),
							lb_longwide = H List Box(
								//radio buttons to choose wide or long format (whether or not to split )
								longwidepb = panelbox("Table format",
									rb_tblformat = radio box({"Long", "Wide"},
										//warn user if using wide format with all archived values
										if( ( ( rb_querytype << Get selected ) == "All Archived Values") & ( ( rb_tblformat << Get selected ) == "Wide"),
											rb_tblformat << Background Color("lightorange");
											New Window( "Huge table warning", Modal, Text Box("Be careful, using a wide table "||
												"with process data can lead to huge tables.  This should only be selected with lab " ||
												"data or when there are relatively few archived values.")
											),
											rb_tblformat << Background Color( 2147483647 );
										);
										UpdateOutput();
									),
								),
								bbHelp("Long: Five columns: Tag, Time, Value, sValue, and Status." ||
									"\!N\!NWide: One row per time, columns for each value.",
									HelpType = "stdradio"
								)
							)
						)
					),
					
					V list box(
						//JSL
						obJMPJSLScript = Outline Box( "JMP JSL to Run Query(Use only for JMP Desktop)",
							JMPJSLout = Script Box(
								"", 750, 400
							),
							<< close;
							<< outlinecloseorientation( "Vertical" )
						),
						Spacer Box( Size( 2, 2 ) ),
						bbHelp( "This script is updated to reflect changes in the options in this window." ||
							"\!N\!NYou can modify the text in this box and then run the query but your changes " ||
							"will be overwritten the next time any other value in the window is changed.",
							HelpType = "stdoutline"
						)
					),
						V list box(
						//JSL
						obLiveJSLScript = Outline Box( "JMP Live JSL to Run Query(Use only for JMP Live)",
							LiveJSLout = Script Box(
								"", 750, 400
							),
							<< close;
							<< outlinecloseorientation( "Vertical" )
						),
						Spacer Box( Size( 2, 2 ) ),
						bbHelp( "This script is updated to reflect changes in the options in this window." ||
							"\!N\!NYou can modify the text in this box and then run the query but your changes " ||
							"will be overwritten the next time any other value in the window is changed.",
							HelpType = "stdoutline"
						)
					)
					
				)
				
			), //end of box with options
			
			//Box to hold command buttons
			H List Box(
			
				//button to run the script
				Button Box( "Run query",
					
					ns:logusage( "Run query" );
					
					Eval( Parse( Eval Expr( Expr( JMPJSLout << get text ) ) ) );

					Try( Eval( Parse( Eval Insert( "dtLong << New Script( \!"JMP Live Data Source\!", ^LiveJSLout << get text^ )" ) ) ) );
					Try( Eval( Parse( Eval Insert( "dtWide << New Script( \!"JMP Live Data Source\!", ^LiveJSLout << get text^ )" ) ) ) );

					Try( Eval( Parse( Eval Insert( "dtLong << New Script( \!"JMP Desktop Data Source\!", ^JMPJSLout << get text^ )" ) ) ) );
					Try( Eval( Parse( Eval Insert( "dtWide << New Script( \!"JMP Desktop Data Source\!", ^JMPJSLout << get text^ )" ) ) ) );

				), //end of 'OK' command button
				
				//button to close the window
				Button Box( "Close/Cancel",
					nw << Close Window;
				),
				
				Button Box( "Help",
					Web(  "file://" || Convert File Path( ns:addinhome ) || "Docs/index.html#File:Help/Help.txt", JMP window )
				),
				
				Button Box( "Examples",
					exmplWin = New Window( "Example Queries",
						V List box(
							Text Box( "Example Queries", <<Set Font Style("bold" )),
							
							lb_ExQuery = List Box( ns:map(exQueries, function({x}, x[1])) ),
							
							Spacer Box( Size( 24, 24 ) ),
							H List Box(
								Button Box( "Load Query", 
									LoadDefault( ( lb_ExQuery << Get Selected )[1] );
									exmplWin << Close Window;
								),
								Button Box( "Close", exmplWin << Close Window() )
							),
							<< Padding( Top(20), Left(20), right(20), bottom(20) )
						)
					)
				),
				
				Button Box( "User Preferences",
					include( "$ADDIN_HOME(com.github.himanga.JMPOSIPITools)\addinUserPrefMenu.jsl" )
				)
				
			), //end of box to hold command buttons
					
			//spacer on bottom of window
			Spacer Box( Size( 12, 12 ) )
			
		), //end of vertical box with heading above all other contents
		
		//spacer in right side of window
		Spacer Box( Size( 12, 12 ) )
		
	) //end of horizontal box for spacers on left and right side
	
); //end of window box


// Example Queries to load
exQueries = {
	{
		"Find PI Tags",
		"Find PI tags matching a name.",
		{
			rb_querytype << Set( 1 ),
			rb_SearchField << Set( 1 ),
			rb_matchtype << Set( 4 ),
			TagList << Set Text( "inusoi"),
			rb_tblformat << Set( 1 )
			
			
		}
	},
	{
		"Find PI Tags by Description",
		"Find PI tags matching a description.",
		{
			rb_querytype << Set( 1 ),
			rb_SearchField << Set( 2 ),
			rb_matchtype << Set( 4 ),
			TagList << Set Text( "Sinusoid"),
			rb_tblformat << Set( 1 )
			
			
		}
	},
	{
		"Interpolated Values",
		"Return evenly-spaced values for a tag.",
		{
			rb_querytype << Set( 4 ),		//Interpolated Values
			TimeStart << Set Text( "t - 2d" ),
			TimeEnd << Set Text( "*" ),
			TimeInterval << Set Text( "1h" ),
			SeparateInterval << Set( 0 ),
			TimeStep << Set Text( "1h" ),
			//rb_calctype << Set( 1 )
			rb_SearchField << Set( 1 ),	//tag
			rb_matchtype << Set( 1 ),		//exact
			TagList << Set Text( "Sinusoid"),
			rb_tblformat << Set( 2 )		//wide
			
			
		}
	},
	{
		"Average Value",
		"Return daily average values",
		{
			rb_querytype << Set( 5 ),
			TimeStart << Set Text( "t - 10d + 6h" ),
			TimeEnd << Set Text( "t + 6h" ),
			TimeInterval << Set Text( "24h" ),
			SeparateInterval << Set( 0 ),
			TimeStep << Set Text( "24h" ),
			//rb_calctype << Set( 1 )
			rb_SearchField << Set( 1 ),	//tag
			rb_matchtype << Set( 1 ),		//exact
			TagList << Set Text( "Sinusoid"),
			rb_tblformat << Set( 2 )		//wide
		}
	}
};

LoadDefault = function( {defname},
	Try(
		DisableUpdate = 1;
		ns:map(exQueries, Function({x},
			if(x[1] == defname,
				ns:map(x[3], Function({x},
					Eval(x);
				))
			)
		) );
		
		DisableUpdate = 0;
		UpdateOutput();
	);
	DisableUpdate = 0;
);

PresetTimes = {
	{"Custom", 						Empty(), 		Empty(), 	Empty(),Empty(), Empty()},
	{"Hourly Yesterday, 12 am", 	"y",			"t", 		"1h", 	0, 		"1h"},
	{"Hourly Yesterday, 6 am" , 	"y+6h",			"t+6h", 	"1h", 	0, 		"1h"},
	{"Hourly Yesterday, 7 am" , 	"y+7h",			"t+7h", 	"1h", 	0, 		"1h"},
	{"Daily Last Year", 			"01/01-1y",		"01/01",	"1d", 	0, 		"1h"},
	{"1 hr moving average", 		"y",			"t",		"1h", 	1, 		"10m"}
};

cb_times << Set Items( ns:map( PresetTimes, function({x}, x[1] ) ) );

//update the screen with initial values.
LoadDefault("Interpolated Values");
cb_tagtonotes << Set(1,1);
UpdateOutput();

//Open script windows if user pref is set
If( ns:UserPref["Open_Script_Windows"] == "yes",
	obJMPJSLScript << Set Open;
);
